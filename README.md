Запуск программы
1. ecu_gw -show - отображает принятые обработанные пакеты. Если пакет не соответствует форматы, то он не отображается.

2. ecu_gw -prev_show - отображает сырую принятую информацию из портов с указанием порта по которому был принят пакет.

3. ecu_gw -send_test PORT - отправляет либо по конкретному порту тест, либо по всем портам тест.
   Формат значения PORT: список портов через _, либо all для отправки во все порты
   При добавлении -show дополнительно печатается hex тестового ECU-кадра перед отправкой

4. ecu_gw -cmd_ui PORT - интерактивный режим отправки COMMAND в один UART-порт.
   Допустимые значения PORT: ttyS1, ttyS4, ttyS5
   После запуска экран делится на две области:
   - верхняя: ввод команды
   - нижняя: принятые ответы с выбранного UART
   Формат команды: cmd <command_id> [hex bytes]
   Дополнительно: src \xHH\xHH... (сырые байты в UART без ECU/SLIP обрамления)
   Обработка входящих данных:
   - если вход проходит SLIP-декодирование и ECU-валидацию, отображается разобранный пакет (как обычно)
   - если вход не проходит SLIP-декодирование, отображается строка:
     SRC: [HEX байты полученного фрагмента]
   Примеры:
   - cmd 7
   - cmd 2 00 10
   - src \x55\xAA
   Выход: q (при пустой строке ввода) или Ctrl+C

5. Обновление через UART без Python-зависимостей (C utility):
```bash
cd src/tools
make t113
```

   Результат сборки для T113:
   - `src/tools/build/t113-static/uart_bl_update`

   Правила использования на плате T113:
   - запускать именно ARM-бинарник `build/t113/uart_bl_update`;
   - порт указывать как путь устройства Linux, например `/dev/ttyS1`;
   - по умолчанию утилита отправляет `ENTER_BOOT`, синхронизируется с bootloader, затем шьет и делает `RUN`;
   - если bootloader уже активен, используйте `--no-enter-boot`;
   - для проверки связи с bootloader без прошивки можно запускать без `--firmware` (будет только `SYNC` и `INFO`);
   - `--chunk` не должен превышать `max_chunk` из `INFO` (утилита автоматически ограничит);
   - для сохранения состояния после прошивки без автозапуска приложения используйте `--no-run`.

   Примеры запуска на T113:
```bash
# 1) Только проверить связь с bootloader
./build/t113-static/uart_bl_update --port /dev/ttyS1 --baud 115200 --no-enter-boot

# 2) Полная прошивка и запуск приложения
./build/t113-static/uart_bl_update --port /dev/ttyS1 --baud 115200 --firmware /path/to/due_app.bin

# 3) Прошивка, но без автозапуска
./build/t113-static/uart_bl_update --port /dev/ttyS1 --baud 115200 --firmware /path/to/due_app.bin --no-run
```

---

## Инструкция инженеру: прошивка SAM3X8E через T113

Ниже рабочий порядок обновления `due_app` на SAM3X8E через UART с платы T113.

1. Подготовить актуальный бинарник приложения для SAM3X8E:
   - собрать проект `due*`;
   - убедиться, что есть файл `build/due_app.bin`.

2. Подготовить updater на T113:
   - вариант A (рекомендуется): использовать ARM-утилиту из `ecu_gw_t113/src/tools/build/t113-static/uart_bl_update`;
   - вариант B: собрать `tools/uart_bl_update` прямо на T113 в нужном проекте `due*`.

3. Скопировать `due_app.bin` на T113 (например, в `/tmp/due_app.bin`).

4. Подключить T113 к целевому SAM3X8E по UART и определить порт Linux на T113 (обычно `/dev/ttyS4`, скорость `115200`).

5. Запустить прошивку на T113:

```bash
uart_bl_update --port /dev/ttyS4 --baud 115200 --firmware /tmp/due_app.bin
```

Если bootloader уже активен, запускать с `--no-enter-boot`:

```bash
uart_bl_update --port /dev/ttyS4 --baud 115200 --firmware /tmp/due_app.bin --no-enter-boot
```

6. Проверить успешность по логам updater:
   - `SYNC: OK`
   - `INFO: ...`
   - `ERASE: OK`
   - `WRITE: ...`
   - `VERIFY: OK`
   - `RUN: OK`

7. Подтвердить запуск приложения на диагностическом UART (FTDI, PA8/PA9, 115200 8N1):
   - `APP start`
   - `APP alive ms=...`

Замечания:
- если нужен только тест связи с bootloader без прошивки, запускайте без `--firmware`;
- для прошивки без автозапуска приложения добавьте `--no-run`;
- файл `due_app.bin` на T113 должен быть именно из актуальной сборки, иначе после `RUN` останется старое поведение.
